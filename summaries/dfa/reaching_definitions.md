Title: Reaching Definitions Analysis
Date: 13.02.2014
Category: II. Data Flow Analysis
Tags: pelican, publishing
Author: Ilija Radosavovic
Summary: Reaching Definitions Analysis

Each place where some variable is assigned, is a definition of that variable.
Consider the following program:    

    int n = 1;
    while(n > 0) {    
        // No assignment to n    
    }    

The only assignment to *n* is before the loop, thus *n* does not change and is always greater than zero.
Therefore the loop does not terminate. [@Ullman]        

*Reaching Definition Analysis* takes an conservative approach.
It is satisfiable to find a subset of the possible improvements, which will still improve the code,
but it is not acceptable to assume an improvement can be made , when that is not possible.     

Consider the following program:        

    int n = 1;    
    while(n > 0) {    
        *p = 0;    
    }    

We can not prove that *p* does not point to *n*, thus we must assume that it does.        

For each program point, *Reaching Definitions analysis* determines which assignments may have been made and not overwritten, when program *reaches* that point along some path.
In other words, a definition *d* of a variable *v* is said to *reach* a point *p* in a flow graph
if there exists some path from the entry of the flow graph to *p* that contains *d*,
and after the last occurrence of *d*, *v* may not be redefined.    

*Reaching Definitions analysis* is mainly used in the construction of direct links between blocks that produce values and blocks that use them.[@Wiklicky]    
Consider the following program:    

    [x:=1]^1;     
    [y:=3]^2;     
    [x:=5]^3;     
    while [x>1]^4 do (    
          [y:=y*y]^5;    
          [x:=x-1]^6)    

All the assignments apart from *1* reach the entry of *5*, however only assignments *3*, *5* and *6* reach entry of *6*.    

Data flow equations:    
$$
  \begin{aligned}
  RDentry(l) = \bigcup \text{predecessors  } l' \text{of } l \text{ } RDexit(l') \\\\
  RDexit(l)  = (RDentry(l) - kill(l)) \bigcup gen(l) \\\\
  \end{aligned}
$$
  

We are interested in the smallest set that satisfies $RDentry$
and use $gen$ and $kill$ functions in order to generate sets of variable label pairs, which will enable us to solve data flow equations.
$gen$ produces variable label pairs generated by the block.
$kill$ destroys variable label pairs which are surely rewritten in the block. [@Nielson]

The following table demonstrates results of $Gen$ and $Kill$ functions, applied to the following program:    

    [x:=1]^1;    
    [y:=3]^2;     
    [x:=5]^3;     
    while [x>1]^4 do (    
          [y:=y*y]^5;    
          [x:=x-1]^6)    


|<center>$l$</center> | <center>$gen(l)$</center> | <center>kill($l$)</center> |
|:-:|:--------:|:-------:|
| 1 | $(x,1)$  |         |
| 2 | $(y,2)$  |         |
| 3 | $(x,3)$  | $(x,1)$ |
| 4 |          |         |
| 5 | $(y,5)$  | $(y,2)$ |
| 6 | $(x,6)$  | $(x,3)$ |


 Finally, we use chaotic iteration to compute the solution:    

|<center>$l$</center> |  <center>RDentry($l$)</center>   |   <center>RDexit($l$)</center>   |
|:-:|:-------------------------------:|:-------------------------------:|
| 1 |                                 | $\\{(x,1)\\}$                   |
| 2 | $\\{(x,1)\\}$                   | $\\{(x,1),(y,2)\\}$             |
| 3 | $\\{(x,1),(y,2)\\}$             | $\\{(x,3),(y,2)\\}$             |
| 4 | $\\{(x,3),(y,2),(y,5),(x,6)\\}$ | $\\{(x,3),(y,2),(y,5),(x,6)\\}$ |
| 5 | $\\{(x,3),(y,2),(y,5),(x,6)\\}$ | $\\{(x,3),(y,5),(x,6)\\}$       |
| 6 | $\\{(x,3),(y,5),(x,6)\\}$       | $\\{(y,5),(x,6)\\}$             |


References
========================================
[@Nielson "Nielson, Flemming, Hanne R. Nielson, and Chris Hankin. Principles of program analysis. Springer, 1999. Page 41-44"]: http://www2.imm.dtu.dk/~hrni/PPA/ppa.html
[@Wiklicky "Herbert Wiklicky, 2013, C470: Program Analysis, Imperial College London"]: http://www.doc.ic.ac.uk/~herbert/teaching/DataFlow.pdf
[@Ullman "Jeffrey Ullman, Shih-wie Liao, Darlene Hadding, Pokey Rule, John Whaley, Joseph Wen, Keith Siilats, 2013, CS243: Program Analysis and Optimisation, Stanford University"]: http://www.stanford.edu/class/cs243/lectures/l2-DFA1.pdf

