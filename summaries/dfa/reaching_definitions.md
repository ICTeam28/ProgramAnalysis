Title: Reaching Definitions Analysis
Date: 13.02.2014
Category: Data Flow Analysis
Tags: pelican, publishing
Author: Ilija Radosavovic
Summary: Reaching Definitions Analysis

Each place where some variable is assigned, is a definition of that variable.
Consider the following program:

int n = 1;
while(n > 0) {
  // No assignment to n
}

The only assignment to n is before the loop, thus n does not change and is always greater than zero. 
Therefore the loop does not terminate. [@Ullman]

Reaching Definition Analysis takes an conservative approach.
It is satisfiable to find a subset of the possible improvements, which will still improve the code, 
but it is not acceptable to assume an improvement can be made , when that is not possible.

Consider the following program:

int n = 1;
while(n > 0) {
  *p = 0;
}

We can not prove that *p* does not point to *n*, thus we must assume that it does.

For each program point, reaching definitions analysis determines which assignments may have been made and not overwritten, when program reaches that point along some path. 
In oder words, a definition *d* of a variable *v* is said to reach a point *p* in a flow graph 
if there exists some path from the entry of the flow graph to *p* that contains *d*, 
and after the last occurrence of *d*, *v* may not be redefined.

Reaching definitions analysis is mainly used in the construction of direct links between blocks that produce values and blocks that use them.
[@Wiklicky]
Consider the following program:

[x:=1]^1; [y:=3]^2; [x:=5]^3; while [x>1]^4 do ([y:=y*y]^5; [x:=x-1]^6)

All the assignments apart from 1 reach the entry of 5, however only assignments 3, 5 and 6 reach entry of 6.

Data flow equations:
RDentry(l) = U predecessors l' of l RDexit(l')
RDexit(l) = (RDentry(l) - Kill(l)) U Gen(l)

We are interested in the smallest set that satisfies RDentry
and use Gen and Kill functions in order to generate sets of variable label pairs, which will enable us to solve data flow equations.
Gen produces variable label pairs generated by the block. 
Kill destroys variable label pairs which are surely rewritten in the block. [@Nielson]

The following table demonstrates results of gen and kill functions applied to the following program:

[x:=1]^1; [y:=3]^2; [x:=5]^3; while [x>1]^4 do ([y:=y*y]^5; [x:=x-1]^6)

| l | gen(l) | kill(l) |
|---|--------|---------|
| 1 | (x,1)  |         |
| 2 | (y,2)  |         |
| 3 | (x,3)  |  (x,1)  |
| 4 |        |         |
| 5 | (y,5)  |  (y,2)  |
| 6 | (x,6)  |  (x,3)  |
|---|--------|---------|  
   
 Finally, we use chaotic iteration to compute the solution:

| l |        RDentry(l)         |         RDexit(l)         |
|---|---------------------------|---------------------------|
| 1 |                           | {(x,1)}                   | 
| 2 | {(x,1)}                   | {(x,1),(y,2)}             |
| 3 | {(x,1),(y,2)}             | {(x,3),(y,2)}             |
| 4 | {(x,3),(y,2),(y,5),(x,6)} | {(x,3),(y,2),(y,5),(x,6)} |
| 5 | {(x,3),(y,2),(y,5),(x,6)} | {(x,3),(y,5),(x,6)}       |
| 6 | {(x,3),(y,5),(x,6)}       | {(y,5),(x,6)}             |
|---|---------------------------|---------------------------|  

   
References
========================================
[@Nielson "Nielson, Flemming, Hanne R. Nielson, and Chris Hankin. Principles of program analysis. Springer, 1999. Page 40-50"]: http://www2.imm.dtu.dk/~hrni/PPA/ppa.html
[@Wiklicky "Herbert Wiklicky, 2013, C470: Program Analysis, Imperial College London"]: http://www.doc.ic.ac.uk/~herbert/teaching/DataFlow.pdf
[@Ullman "Jeffrey Ullman, Shih-wie Liao, Darlene Hadding, Pokey Rule, John Whaley, Joseph Wen, Keith Siilats, 2013, CS243: Program Analysis and Optimisation, Stanford University"]: http://www.stanford.edu/class/cs243/lectures/l2-DFA1.pdf

