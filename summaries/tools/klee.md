Title: KLEE
Date: 11.03.2014
Category: IV. Tools for Program Analysis
Tags: pelican, publishing
Author: Nandor Licker
Summary: KLEE is a sybolic execution tool

KLEE is a symbolic execution tool which can automatically generate tests and
find bugs in complex applications. It was used to run tests on GNU Coreutils,
achieving a coverage of 90% and finding 3 serious bugs. [@KLEE]

KLEE does not run programs, it executes them symbolically, trying to trace the
values of all variables through all the possible paths of execution. Values can
be either concrete (computable constants) or be represented as constraints over
specific domains. When an exit point is reached in a program, it tries to
retrace its steps and generate a test case to cover that specific path.
Theoretically, KLEE was designed to be sound (a program should always follow the
path KLEE took when running a specific test case), but in practice false
positives might be generated.

KLEE interprets the bytecode generated by llvm frontends (llvm-gcc, for example).
Internally, it stores a list of states, saving the heap, stack and program
In one iteration, KLEE selects a state from the pool and executes a single
instruction. If the exact value for a variable cannot be computed, KLEE stores
the expression tree. When conditionals are encountered, KLEE tries to evaluate
the conditions in order to determine whether they are true or false. If the
truth value can be determined, only one of the branches is followed. Otherwise,
both branches are added to the list of states and constraints are updated. New
branches are also generated in order to check for potential bugs. For example,
when an array element is accessed, KLEE checks whether the index is within
bounds. If a check fails, KLEE reports an error and tries to generate a test
case which will trigger it.

The constraint solver used by KLEE is STP [@STP]. Due to the fact that
constraint solving is an expensive process, KLEE tries to simplify expressions
and cache common queries.

In order to check whether a program interracts with the environment correctly,
klee provides a modified version of the uclibc library. Common linux syscalls,
like read, write, open etc. are re-implemented to generate the required
constraints for inputs and outputs.

Example
-------

We tried out KLEE on a piece of exceptionally badly written C code. We compiled
and tested the code with the following commands:

    $ clang --emit-llvm -S test.c -o test.ll
    $ klee -max-time 2 test.ll
    $ python2 klee-stats klee-out-* > stats.txt

test.c tries to implement Euclid's algorithm along with conversions functions
between strings and integers:

    int atoi(const char *str)
    {
      int a;

      a = 0;
      while (*str) {
        a = a * 10 + *str - '0';
        ++str;
      }

      return a;
    }

    int itoa(int a, char * buf)
    {
      char * beg;
      long len, i;

      beg = buf;
      do {
        *buf = a % 10 + '0';
        a /= 10;
        ++buf;
      } while (a);
      *buf = '\0';

      len = buf - beg;
      for (i = 0; i < (len >> 1); ++i) {
        char tmp = beg[i];
        beg[i] = beg[len - i - 1];
        beg[len - i - 1] = tmp;
      }
    }

    int gcd(int a, int b)
    {
      do {
        int r = a % b;

        a = b;
        b = r;
      } while (b);

      return a;
    }

    int main(int argc, char **argv)
    {
      int a, b;
      char buf[5];

      klee_make_symbolic(&a, sizeof(a), "a");
      klee_make_symbolic(&a, sizeof(a), "b");

      a = atoi(argv[0]);
      b = atoi(argv[1]);

      puts(itoa(gcd(a, b), buf));
    }

KLEE immediately reported the following errors:

    KLEE: ERROR: test.c:6: memory error: out of bound pointer
    KLEE: ERROR: test.c:26: memory error: out of bound pointer
    KLEE: ERROR: test.c:30: memory error: out of bound pointer
    KLEE: ERROR: test.c:43: divide by zero

The code was rewritten in order to fix buffer overflows & null pointer
divisions. It should be noted that itoa would still crash if it receives an
empty string (buf = NULL, max = 0), as it would write '\0' to address buf - 1.
This case wasn't detected by KLEE.

    int atoi(const char *str)
    {
      int a;

      if (!str) {
        return 0;
      }

      a = 0;
      while (*str) {
        a = a * 10 + *str - '0';
        ++str;
      }

      return a;
    }

    int itoa(int a, char * buf, int max)
    {
      char * beg;
      long len, i;

      beg = buf;
      do {
        if (buf - beg < max) {    // Clip output if outside of array bounds
          *buf = a % 10 + '0';
          ++buf;
        }
        a /= 10;
      } while (a);

      if (buf - beg < max) {      // Don't forget about the null terminator
        *buf = '\0';
      } else {
        *(beg + max - 1) = '\0';
      }

      len = buf - beg;
      for (i = 0; i < (len >> 1); ++i) {
        char tmp = beg[i];
        beg[i] = beg[len - i - 1];
        beg[len - i - 1] = tmp;
      }
    }

    int gcd(int a, int b)
    {
      while (b) {               // Make sure we don't divide by zero
        int r = a % b;

        a = b;
        b = r;
      }

      return a;
    }

    int main(int argc, char **argv)
    {
      int a, b;
      char buf[2];

      klee_make_symbolic(&a, sizeof(a), "a");
      klee_make_symbolic(&a, sizeof(a), "b");

      a = atoi(argv[0]);
      b = atoi(argv[1]);

      itoa(gcd(a, b), buf, sizeof(buf));
    }

Conclusions
-----------

KLEE allowed us to easily detect several fatal flaws in our simple test case.
Statistics generated by klee-stats show that klee managed to cover 60.63% of
the codebase and traced 50% of the branches. [@kleestats]
Although KLEE is neither sound nor complete, it is impressive that it still
manages to find buffer overflows in the world's most used applications
(GNU coreutils).

| Path     | Instrs | Time(s) | ICov(%) | BCov(%) | ICount | TSolver(%) |
| -------- | ------ | ------- | ------- | ------- | ------ | ---------- |
| klee-out |    474 |   0.00  |  60.63  |   50.00 |    254 |      35.30 |



References
---------

[@KLEE "KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs"]: https://www.doc.ic.ac.uk/~cristic/papers/klee-osdi-08.pdf
[@STP "A Decision Procedure for Bit-Vectors and Arrays"]:http://chicory.stanford.edu/PAPERS/STP-ganesh-07.pdf
[@kleestats "klee-stats"]:http://klee.github.io/klee/klee-tools.html