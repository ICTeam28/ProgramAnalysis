Title: KLEE
Date: 11.03.2014
Category: IV. Tools for Program Analysis
Tags: pelican, publishing
Author: Nandor Licker
Summary: KLEE is a sybolic execution tool

KLEE is a symbolic execution tool which can automatically generate tests and
find bugs in complex applications. It was used to run tests on GNU Coreutils,
achieving a coverage of 90% and finding 3 serious bugs. Tests generated by
KLEE can achieve a high coverage of the codebase. [@KLEE]

KLEE does not run programs, instead it executes them symbolically, trying to
trace the values of all variables through all the possible paths of execution.
Values can be either concrete (computable constants) or be represented as
constraints over specific domains. When an exit point is reached in a program,
it tries to retrace its steps and generate a test case to cover that specific
path. Theoretically, KLEE was designed to be sound (a program should always
follow the path KLEE took when running a specific test case), but in practice
false errors might be reported.

KLEE interprets the bytecode generated by llvm frontends (llvm-gcc, for example).
Internally, it stores a list of states, saving the heap, stack and program
In one iteration, KLEE selects a state from the pool and executes a single
instruction. If the exact value for a variable cannot be computed, KLEE stores
the expression tree. When conditionals are encountered, KLEE tries to evaluate
the conditions in order to determine whether they are true or false. If the
truth value can be determined, only one of the branches is followed. Otherwise,
both branches are added to the list of states and constraints are updated. New
branches are also generated in order to check for potential bugs. For example,
when an array element is accessed, KLEE checks whether the index is within
bounds. If a check fails, KLEE reports an error and tries to generate a test
case which will trigger it.

The constraint solver used by KLEE is STP [@STP]. Due to the fact that
constraint solving is an expensive process, KLEE tries to simplify expressions
and cache common queries.

In order to check whether a program interracts with the environment correctly,
klee provides a modified version of the uclibc library. Common linux syscalls,
like read, write, open etc. are re-implemented to generate the required
constraints for inputs and outputs.

Example
-------

We tried out KLEE on a piece of exceptionally badly written C code. We compiled
and tested the code with the following commands:

    $ clang --emit-llvm -S test.c -o test.ll
    $ klee -max-time 2 test.ll
    $ python2 klee-stats klee-out-* > stats.txt

test.c tries to implement Euclid's algorithm along with conversions functions
between strings and integers:

     1. int atoi(const char *str)
     2. {
     3.   int a;
     4.
     5.   a = 0;
     6.   // Null pointer might be dereferenced here
     7.   while (*str) {
     8.     a = a * 10 + *str - '0';
     9.     ++str;
    10.   }
    11.
    12.   return a;
    13. }
    14.
    15. int itoa(int a, char * buf)
    16. {
    17.   char * beg;
    18.   long len, i;
    19.
    20.   beg = buf;
    21.   do {
    22.     // Null pointer or buffer overflow
    23.     *buf = a % 10 + '0';
    24.     a /= 10;
    25.     ++buf;
    26.   } while (a);
    27.
    28.   // Null pointer or buffer overflow again
    29.   *buf = '\0';
    30.
    31.   len = buf - beg;
    32.   for (i = 0; i < (len >> 1); ++i) {
    33.     char tmp = beg[i];
    34.     beg[i] = beg[len - i - 1];
    35.     beg[len - i - 1] = tmp;
    36.   }
    37. }
    38.
    39. int gcd(int a, int b)
    40. {
    41.   do {
    42.     // Division by zero
    43.     int r = a % b;
    44.
    45.     a = b;
    46.     b = r;
    47.   } while (b);
    48.
    49.   return a;
    50. }
    51.
    52. int main(int argc, char **argv)
    53. {
    54.   int a, b;
    55.   char buf[5];
    56.
    57.   klee_make_symbolic(&a, sizeof(a), "a");
    58.   klee_make_symbolic(&a, sizeof(a), "b");
    59.
    60.   a = atoi(argv[0]);
    61.   b = atoi(argv[1]);
    62.
    63.   puts(itoa(gcd(a, b), buf));
    64. }

KLEE immediately reported the following errors:

    KLEE: ERROR: test.c:7: memory error: out of bound pointer
    KLEE: ERROR: test.c:23: memory error: out of bound pointer
    KLEE: ERROR: test.c:29: memory error: out of bound pointer
    KLEE: ERROR: test.c:42: divide by zero

The code was rewritten in order to fix buffer overflows & division by zero.
It should be noted that itoa would still crash if it receives an empty string
(buf = NULL, max = 0), as it would write '\0' to address buf - 1. This case
was not detected by KLEE.

     1. int atoi(const char *str)
     2. {
     3.   int a;
     4.
     5.   if (!str) {
     6.     return 0;
     7.   }
     8.
     9.   a = 0;
    10.   while (*str) {
    11.     a = a * 10 + *str - '0';
    12.     ++str;
    13.   }
    14.
    15.   return a;
    16. }
    17.
    18. int itoa(int a, char * buf, int max)
    19. {
    20.   char * beg;
    21.   long len, i;
    22.
    23.   beg = buf;
    24.   do {
    25.     if (buf - beg < max) {    // Clip output if outside bounds
    26.       *buf = a % 10 + '0';
    27.       ++buf;
    28.     }
    29.     a /= 10;
    30.   } while (a);
    31.
    32.   if (buf - beg < max) {      // Don't forget about the terminator
    33.     *buf = '\0';
    34.   } else {
    35.     *(beg + max - 1) = '\0';  // Could still crash!
    36.   }
    37.
    38.   len = buf - beg;
    39.   for (i = 0; i < (len >> 1); ++i) {
    40.     char tmp = beg[i];
    41.     beg[i] = beg[len - i - 1];
    42.     beg[len - i - 1] = tmp;
    43.   }
    44. }
    45.
    46. int gcd(int a, int b)
    47. {
    48.   while (b) {               // Make sure we don't divide by zero
    49.     int r = a % b;
    50.
    51.     a = b;
    52.     b = r;
    53.   }
    54.
    55.   return a;
    56. }
    57.
    58. int main(int argc, char **argv)
    59. {
    60.   int a, b;
    61.   char buf[2];
    62.
    63.   klee_make_symbolic(&a, sizeof(a), "a");
    64.   klee_make_symbolic(&a, sizeof(a), "b");
    65.
    66.   a = atoi(argv[0]);
    67.   b = atoi(argv[1]);
    68.
    69.   itoa(gcd(a, b), buf, sizeof(buf));
    70. }

Conclusions
-----------

KLEE allowed us to easily detect several fatal flaws in our simple test case.
Statistics generated by klee-stats show that klee managed to cover 60.63% of
the codebase and traced 50% of the branches. [@kleestats]
Although KLEE is neither sound nor complete, it is impressive that it still
manages to find buffer overflows in the world's most used applications
(GNU coreutils).

| Path     | Instrs | Time(s) | ICov(%) | BCov(%) | ICount | TSolver(%) |
| -------- | ------ | ------- | ------- | ------- | ------ | ---------- |
| klee-out |    474 |   0.00  |  60.63  |   50.00 |    254 |      35.30 |



References
---------

[@KLEE "KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs"]: https://www.doc.ic.ac.uk/~cristic/papers/klee-osdi-08.pdf
[@STP "A Decision Procedure for Bit-Vectors and Arrays"]:http://chicory.stanford.edu/PAPERS/STP-ganesh-07.pdf
[@kleestats "klee-stats"]:http://klee.github.io/klee/klee-tools.html